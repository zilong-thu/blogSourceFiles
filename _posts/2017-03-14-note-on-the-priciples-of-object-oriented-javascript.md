---
title: 《JavaScript面向对象精要》笔记
date: 2017-03-14 23:55:00
tags: JavaScript
categories: JavaScript
---

## 一切皆对象

> 其他编程语言用栈储存原始类型，用堆储存引用类型，JavaScript 则完全不同：它是以一个变量对象追踪变量的生存期。原始值被直接保存在变量对象内，而引用值则作为一个指针保存在变量对象内，该指针指向实际对象在内存中的存储位置。
> page 2

例如，所有的 JavaScript 对象都有一个方法 `Object.prototype.valueOf()`，该方法返回指定对象的原始值。如果我们一个简单的赋值语句：

```
var a = 1;
```

那么我们会发现变量 `a` 上面其实有很多方法（当然，大部分都是来自于其原型）。这就是因为该变量是通过变量对象进行追踪的，并不仅仅只有一个值（这也涉及一个概念，“原始封装类型”）。这也是 JavaScript “一切皆为对象”的理念。


## JavaScript 只有值传递

我们知道，JavaScript 是只有值传递的。而下面的描述则更为深入地解释了内在机理：

> 当你讲原始值赋给一个变量时，该值将被复制到变量中。也就是说，如果你使一个变量等于另一个时，每个变量有它自己的一份数据拷贝。
> ……每个含有原始值的变量使用自己的存储空间。
> page 3

## 鉴别数组

`Array.isArray()` 方法是 ES5 标准所提出的。目前的支持度已经非常好。IE9+，Chrome/Safari/FireFox 都支持此 API。

## 函数

> 函数其实就是对象。使函数不同于其他对象的决定性特点是函数存在一个被称为 `[[Call]]` 的内部属性。
> ……`[[Call]]` 是函数独有的，表明该对象可以被执行。由于仅函数拥有该属性，ECMAScript 定义 `typeof` 操作符对任何具有 `[[Call]]` 属性的对象返回 “function”。这在过去曾经导致一些问题，因为某些浏览器曾经在正则表达式中包含 `[[Call]]` 属性，导致后者被错误鉴别为函数。现在，所有浏览器行为都一致，`typeof` 不会再将正则表达式鉴别为函数了。

函数是 JavaScript 语言的核心。一大特点就是：函数即对象。所以，函数可以被传递来传递去……

page 18 里面对函数声明、函数表达式进行了对比。不过，对于一个细节，并没有挖得很深。这里简单说一下，大概是“当我们说起函数作用域时，你可曾忘记了什么？”。考虑下面的一段代码：

```
var func = 'test';

var func1 = function func(a) {
  console.log(typeof func);  // function
}

func1();

console.log(func1.name);  // func
```

一个函数字面量包含这几部分：

+ 关键字`function`
+ 空格
+ 函数名（function name），非必须
+ (形参列表)
+ {函数体}

其中，函数名、所有的形参，也都属于该函数作用域。这就是为什么在该函数内部，`func` 会屏蔽外部的变量。
